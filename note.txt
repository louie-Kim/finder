-- 실제 finding 에 필요한 돔 요소 
iframe#mainFrame :  실제 에디터 DOM은 이 안에 있음

iframe 내부 돔 요소 카피해오기

// iframe 전체 HTML
const iframe = document.getElementById("mainFrame");
const doc = iframe.contentDocument || iframe.contentWindow.document;
copy(doc.documentElement.outerHTML); // 이거 사용했음 (개발자 도구 콘솔에서 돌림)

// iframe 내부 body만
copy(doc.body.innerHTML);



---------------------------------------------------------------------------------

-- 단어 단위 \w  검색 문제

ASCII word 문자 ( 영문만 인식 )

\w = [A-Z, a-z, 0-9, _  ] 을 뜻하는 정규식 

-- 1. /\w/    // 한 글자씩 word 문자 검사 -----------

"A B 3 _ !"

A   // 한 글자
B   // 한 글자
3   // 숫자 한 글자
_   // 언더스코어 한 글자

!   (**매칭 안 됨**)


--2. /\w+/   // 연속된 word 문자(단어) 검사 ----------

"Hello 123 _World!"

Hello      // 연속된 영문
123        // 연속된 숫자
_World     // 언더스코어 + 영문이 연속된 word



ASCII word 문자 ( 영문만 인식 ) -> 유니코드 속성 기반으로 확장해야 함. ( 한글 인식까지 확장 )



\w   → * 는 매칭 안 됨

\w  = 단어 문자 = [A-Z a-z 0-9 _]  (영문/숫자/밑줄)
\W  = 비단어 문자 = (\w가 아닌 나머지) (@, #, $, %, …)



*1

*는 비단어 문자 + 1은 단어 문자
검색어 전체가 단어 문자만으로 이루어지지 않아서 '단어 단위 규칙을 적용하지 않음"
(AB(단어 단위) 켜도) 결과적으로 *1은 '일반 문자열' 검색으로 처리됨 

예: *1, a+b, #tag 같은 경우


ASCII는 문자 “집합”이며, \w는 “단어 문자로 간주되는 것만 골라 쓰는 정규식 패턴”


----------------------------------------------------------------------------------------------

https://www.youtube.com/watch?v=lwZ8q0kYGPU 참고

vercel-react-best-practices 스킬 설치 했음

이 스킬은 React/Next.js 작업 시 성능·번들·렌더링 최적화 가이드를 적용해 주는 거예요. 예를 들면:

  - 데이터 페칭 병렬화, 워터폴 제거
  - 번들 크기 줄이기(직접 import, dynamic import 등)
  - 서버/클라이언트 렌더링 성능 개선
  - 리렌더 최소화(메모화, 의존성 정리)
  - JS 루프 최적화, 캐싱 패턴 적용

  즉, 코드 리뷰나 리팩터링 요청이 들어오면 이 규칙들로 개선 포인트를 찾고 수정까지 진행할 수 있습니다. 원하는 파일이나 작업을 알려
  주세요.

ex) 1.코드베이스 전체 감사를 하고 개선 계획을 세워줘.
    2.결과 보고서를 예쁜 서식으로 해서 내용 상세하게 해서 report.html 파일로 만들어줘. 코드 하이라이팅도 해줘.
    




브라우저 확장 쪽(extension/)은 React/Next.js가 아니라서 이 스킬 적용 대상이 아닙니다.



-----------------------------------------------------------------------------------------

✅ Copy outer HTML

👉 선택한 해당 요소 자기 "자신 태그 + 그 안의 자식 요소들" 전체를 복사합니다.
즉
<div> … </div> 형태로 시작 태그부터 끝 태그까지 포함해서 가져오는 거예요.

✅ Copy inner HTML

👉 선택한 요소의 "자식 요소들(내용)만" 복사합니다.
즉
<div> 자기 자신 태그는 포함 안 하고, 그 안에 들어 있는 내용(자식들)만 가져오죠.

--------------------------------------------------------------------------------------------------------

하나씩 바꾸기 기능 변경 ( 전체 바꾸기로직을 따름 )

before) 기존 단일: 활성 매치 1건을 직접 선택해서 replaceInInput/DOM 조작 분기(블로그 전용 분기 포함)로 치환.

 블로그 DOM 구조(.se-content, .__se-node 등)를 기준으로 선택/치환을 시도
 -->  매치 계산(정규식/문자열) → DOM 치환인데, 대상별(블로그/일반/입력)로 분기가 많았다는 점 (복잡 failed)

after) 변경 후 단일: refreshMatches()로 매치 목록을 만든 다음, getSearchRegex() 기준으로 선택된 매치 1건만 치환.

블로그 전용 DOM 분기 없이, refreshMatches()가 만든 매치 목록(정규식)을 기준으로 1건만 치환
  --> 매치 계산(정규식/문자열) → DOM 치환인데, 대상별(블로그/일반/입력)로 분기가 줄어 듬 ( 대상 불일치/포커스/선택 이슈가 덜 생김 succeeded )

--------------------------------------------------------------------------------------------------------

-- vercel-react-best-practices 적용후...

실행 순서는 이렇게 됩니다 (Next.js App Router 기준):

서버가 page.tsx를 먼저 렌더링
그 안에서 <EditorSection /> 자리가 나오지만, 아직 클라이언트 컴포넌트라 내용은 비어 있음
브라우저가 JS를 받아서 EditorSection.tsx를 실행
dynamic()이 CodeMirror(FindReplaceEditor)를 비동기로 가져옴
로딩 중에는 스켈레톤 UI가 보임
로딩 완료되면 FindReplaceEditor가 실제로 렌더링됨


즉, “페이지 틀은 서버 → 에디터는 브라우저에서 나중에 로드” 순서입니다.



**번들이란 웹 개발에서 브라우저가 요청하는 여러 코드(자바스크립트, CSS, 이미지 등)를 하나 또는 몇 개의 파일로 “묶어 놓은 결과물”**이에요. 
즉, 개발자가 쪼개서 만든 여러 파일을 하나로 합쳐서 브라우저가 받게 되는 파일이라고 보면 됩니다

-------------------------------------------------------------------------------------------------

@next/bundle-analyzer가 빌드 결과를 분석해서 브라우저/엣지/노드(서버) 용 '번들 크기'를 
시각화한 HTML을  .next/analyze/에 생성.

client.html: 
브라우저(클라이언트)가 받는 정적 JS 번들들의 구성/비중을 보여주는 리포트
-> 브라우저(클라이언트) 번들 리포트


edge.html: Edge 런타임 번들 분석

nodejs.html: 
서버 런타임에서 로드되는 번들들의 구성/비중 ( 브라우저가 직접 요청하는 리소스가 아님 )
-> 서버사이드(Node.js) 번들 리포트


